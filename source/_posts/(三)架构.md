---
title: (三)架构
date: 2019-12-27 19:56:56
categories:
 - DDD
tags:
 - DDD
 - 领域驱动设计
---

## 分层架构

{% asset_img 1.png %}

{% tabs 分层架构 %}

<!-- tab 用户接口层 -->

负责向用户显示信息和解释用户指令。这里指的用户可以是另一个计算机系统，不一定是使用用户界面的人。

<!-- endtab -->

<!-- tab 应用层 -->

定义软件要完成的任务，并且指挥表达领域概念的对象来解决问题。这一层所负责的工作对业务来说意义重大，也是与其他系统应用层进行交互的必要渠道。



应用层要尽量简单，不包含业务规则或者知识，而只为下一层的领域对象协调任务，分配工作，使它们互相协作。它没有反映业务情况状态，但是却可以具有另一种状态，为用户或程序显示某个任务的进度。

<!-- endtab -->

<!-- tab 领域层 -->

负责表达业务概念，业务状态信息以及业务规则。尽管保持业务状态的技术细节是由基础设施层实现的。但是反映业务情况的状态是由本层控制并且使用的。`领域层是业务软件的核心。`

<!-- endtab -->

<!-- tab 基础设施层 -->

为上面各层提供通用的技术能力：为应用层传递消息，为领域层提供持久化机制，为用户界面层绘制屏幕组件等等。基础设施层还能通过架构框架来支持四个层间的交互模式。

<!-- endtab -->

{% endtabs %}

*这个分层架构我们可能会感觉很熟悉，因为有很多系统都采用了类似的分层模式或者其变种。但是这里强调的是`领域层`，而且我们的业务代码应该在领域层，而现实中我看到的代码很多业务逻辑都涉及到了用户接口层。当然，也不是所有系统都应该按照分层模式来设计。但是，复杂系统应该做到解耦。*

> 采用标准的分层架构模式，只与上层进行松散连接。将所有与领域模型相关的代码放在一个层中，并把它与用户界面层、应用层以及基础设施层的代码分开。领域对象应该将重点放在如何表达领域模型上，而不需要考虑自己的显示和存储问题，也无需管理应用任务等内容。这使得模型的含义足够丰富，结构足够清晰，可以捕捉到基本的业务知识，并有效地使用这些知识。

> 事实上，较低层也是可以和较高层发生耦合的，但是这只局限于采用`观察者（Observer）`模式或`调停者（Mediator）`模式的情况。较低层是绝对不能直接访问较高层的。

### 依赖倒置原则

> 高层模块不应该依赖于底层模块，两者都应该依赖于抽象。
> 抽象不应该依赖于细节，细节应该依赖于抽象。

> 我们应该将关注点放在领域层上，采用依赖导致原则，使领域层和基础设施层都只依赖于由领域模型定义的抽象接口。由于应用层是领域层的直接客户，它将依赖于领域层接口，并且间接地访问资源库和由基础设施层提供的实现类。

## 六边形架构

{% asset_img 2.png %}

> 六边形架构提倡用一种新的视角来看待整个系统，如图所示。该架构中存在两个区域，分别是"外部区域"和“内部区域”。在外部区域中，不同的客户均可以提交输入；而内部的系统则用于获取持久化数据，并对程序进行存储（比如数据库），或者在中途将输出转发到另外的地方（比如消息）。

> 有3个客户请求均抵达相同的输入端口（适配器A、B和C），另一个客户请求使用了适配器D。可能前3个请求使用了HTTP协议（浏览器、REST和SOAP等），而后一个请求使用了AMQP协议（比如RabbitMQ）。端口并没有明确的定义，它是一个非常灵活的概念。无论采用哪种方式对端口进行划分，当客户请求到达时，都应该有相应的适配器对输入进行转化，然后端口将调用应用程序的某个操作或者向应用程序发送一个事件，控制权由此交给内部区域。

